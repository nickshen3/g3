//! Integration tests for logging functionality

use std::fs;
use std::path::Path;

#[test]
fn test_log_files_created() {
    // This test verifies that the logging functions work correctly
    // by checking that files can be created in the logs directory
    
    // Clean up any existing test logs
    let _ = fs::remove_dir_all("logs");
    
    // Create logs directory
    fs::create_dir_all("logs").expect("Failed to create logs directory");
    
    // Verify directory exists
    assert!(Path::new("logs").exists());
    assert!(Path::new("logs").is_dir());
    
    // Test writing a code report
    let test_report = "Test codebase report\nLine 2\nLine 3";
    let timestamp = chrono::Local::now().format("%Y%m%d_%H%M%S").to_string();
    let report_filename = format!("logs/code_report_{}.log", timestamp);
    
    fs::write(&report_filename, test_report).expect("Failed to write code report");
    assert!(Path::new(&report_filename).exists());
    
    let content = fs::read_to_string(&report_filename).expect("Failed to read code report");
    assert_eq!(content, test_report);
    
    // Test writing discovery commands
    let commands_filename = format!("logs/discovery_commands_{}.log", timestamp);
    let test_commands = "# Discovery Commands\n# Generated by g3-planner\n\nls -la\ncat README.md\n";
    
    fs::write(&commands_filename, test_commands).expect("Failed to write discovery commands");
    assert!(Path::new(&commands_filename).exists());
    
    let content = fs::read_to_string(&commands_filename).expect("Failed to read discovery commands");
    assert_eq!(content, test_commands);
    
    // Clean up
    let _ = fs::remove_file(&report_filename);
    let _ = fs::remove_file(&commands_filename);
}

#[test]
fn test_filename_format() {
    // Verify the filename format matches the tool_calls log format
    let timestamp = chrono::Local::now().format("%Y%m%d_%H%M%S").to_string();
    
    // Check format: YYYYMMDD_HHMMSS
    assert_eq!(timestamp.len(), 15); // 8 digits + underscore + 6 digits
    assert!(timestamp.contains('_'));
    
    let parts: Vec<&str> = timestamp.split('_').collect();
    assert_eq!(parts.len(), 2);
    assert_eq!(parts[0].len(), 8); // YYYYMMDD
    assert_eq!(parts[1].len(), 6); // HHMMSS
}
